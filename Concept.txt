Layered approach
1) Parsing the file for tokens				{I need to make a vector of vector of tokens}
									Done by	(vectorize_file) which is the first layer of parsing
											(token_generator) which is the second layer of parsing
											() which is the third layer of parsing
In terms of parsing it will be
{
	var1 = 42
	var2 = 55 555 "hello"
	println var1 var2 55 123 "hello			// This will be broken down into (println)[print] 
}
											<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>
2) Then checking for any problems			{This will ckeck for incomplete statement, using unknown variable when trying to look them up}
											<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>
3) Compiling 								{Using the pick_statement function with all the parsed vector of vector of tokens built up}
											<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>
4) Executing								{Using the function exec}

// code
{
	Data_Type var = value // Initialization
	// class name {}; // For later
	// Inside body
	{
		while (expression) {code}
		if (expression) {code}
		for (Initialization; expression; operation) {code}
	}
	// Outside body
	{		
		Data_Type func(params) {code}
	}
}

	 if   hello equal "hello" println hello
	 ^^   ^^^^^ ^^^^^ ^^^^^^^ ^^^^^^^ ^^^^^
keyword |	  expression     |	  code
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				code

expression could be:
		variable operator variable
		variable operator constant
		constant operator varaible
		constant operator constant
		boolean variable
		boolean constant

variables could be:
		variable name (where the first element will be picked)
		variable indexed (where the element indexed will be picked [0-index method])
		function return (will be though of later lol)

constants could be:
		DataType values (True or False / integral values / decimal values / string / null)

keywords could be:
		A word reserved for a function
		A word reserved for a DataType value (True or False / null)
<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>
When creating a variable we go

[variable name] = val1 val2 val3		OR
[variable name] = [variable name]
<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>
When creating a print statement we go
print(ln) val1 val2 val3
print(ln) [variable name]
<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>-<=>
When setting a variable we go

[variable name][[index]] = val			OR
[variable name] = val1 val2 val3

// First one only accounts for one variable, second accounts for multiple